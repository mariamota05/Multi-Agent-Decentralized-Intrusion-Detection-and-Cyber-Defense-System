"""
Malware Attacker - Infects systems with persistent background malware

ATTACK TYPE: Persistent Malware Infection
────────────────────────────────────────────────────────────────

WHAT IT DOES:
  • Sends infection payloads to target nodes
  • Once infected, nodes get persistent performance degradation:
    -> +20% CPU overhead on EVERY message processed
    -> Simulates malware running in background
  • Stealth timing to avoid rate-based detection
  • Infection persists until firewall blocks/quarantines

HOW INFECTION WORKS:
  1. Attacker sends INFECT message to target
  2. Node receives and processes it (applies infection)
  3. Node's "malware_infection" state set to True
  4. ALL subsequent message processing gets +20% CPU penalty
  5. Infection remains until incident response clears it

WHY THIS RESPONSE?
  [+] Immediate permanent block - malware SPREADS fast
  [+] Quarantine advisory - isolate infected systems
  [+] Fastest response (0.3s) - every second counts
  [+] No investigation needed - malware = definite threat

RISK LEVEL: [!] CRITICAL
  - Persistent resource drain on infected nodes
  - Performance degradation affects ALL operations
  - Can spread if attacker infects multiple nodes
  - Only removable by incident response intervention
────────────────────────────────────────────────────────────────

Usage:
  python attackers/malware_attacker.py --jid attacker@localhost --password secret \\
         --targets node1@localhost,node2@localhost --intensity 5 --duration 30
"""

import argparse
import asyncio
import datetime
import getpass
import json

import spade
from spade.agent import Agent
from spade.behaviour import PeriodicBehaviour
from spade.message import Message


def _log(msg: str) -> None:
    """Log helper for attacker script with timestamp.

    Args:
        msg (str): The message to display.
    """
    ts = datetime.datetime.now().strftime("%H:%M:%S")
    print(f"[{ts}] [MALWARE] {msg}")


class MalwareAttacker(Agent):
    """Sends infection payloads that cause persistent performance degradation."""

    class StealthMalwareBehaviour(PeriodicBehaviour):
        """Sends malware infection payloads to compromise nodes."""

        async def on_start(self):
            """Initializes the infection counter and target index upon starting the behavior."""
            _log(f"Starting malware infection campaign from {self.agent.jid}")
            self.infections_sent = 0
            self.agent.set("target_index", 0)
            self.agent.set("msg_index", 0)

        async def run(self):
            """Executes a single periodic attempt to infect a target node."""
            targets = self.agent.get("targets") or []
            intensity = int(self.agent.get("intensity") or 3)

            if not targets:
                return

            # Round-robin target selection
            target_index = self.agent.get("target_index") or 0
            target_node_jid = targets[target_index % len(targets)]
            self.agent.set("target_index", (target_index + 1) % len(targets))

            # Extract router from target node JID
            try:
                router_name = target_node_jid.split('_')[0]
                domain = target_node_jid.split('@')[1]
                target_router_jid = f"{router_name}@{domain}"
            except Exception:
                _log(f"Error: Cannot extract router JID from {target_node_jid}")
                target_router_jid = target_node_jid

            # Malware infection payloads - using stealth names to bypass keyword detection
            # Real malware uses legitimate-looking process names for evasion
            payloads = [
                "INFECT:svchost.update.persistent",
                "INFECT:chrome.helper.background",
                "INFECT:system.indexer.service",
                "INFECT:update.scheduler.delayed",
                "INFECT:network.optimizer.auto",
                "INFECT:analytics.collector.daemon"
            ]

            # Cycle through payloads
            msg_index = self.agent.get("msg_index") or 0
            payload = payloads[msg_index % len(payloads)]
            self.agent.set("msg_index", (msg_index + 1) % len(payloads))

            # Send infection message
            msg = Message(to=target_router_jid)
            msg.set_metadata("dst", target_node_jid)
            msg.set_metadata("protocol", "malware-infection")
            msg.set_metadata("attacker_intensity", str(intensity))  # Track sophistication for cure difficulty

            # The infection itself has minimal initial CPU impact
            # (the persistent overhead comes after infection)
            task_data = {
                "cpu_load": 3.0,  # Initial infection overhead
                "duration": 1.0
            }
            msg.set_metadata("task", json.dumps(task_data))
            msg.body = payload

            await self.send(msg)
            self.infections_sent += 1

            _log(f"[{self.infections_sent}] Infection attempt -> {target_node_jid.split('@')[0]}: {payload.split(':')[1]}")

            # Check if duration expired (Note: Duration checking might be better handled in main loop or behaviour's run/on_time)
            duration = self.agent.get("duration") or 30
            start_time = self.agent.get("attack_start_time") or 0
            if asyncio.get_event_loop().time() - start_time > duration:
                 _log(f"Attack duration expired after {self.infections_sent} infections - stopping")
                 self.kill()


    async def setup(self):
        """Sets up the MalwareAttacker by storing the start time and adding the StealthMalwareBehaviour."""
        _log(f"Malware attacker initialized: {self.jid}")

        # Store attack start time
        self.set("attack_start_time", asyncio.get_event_loop().time())

        # Start stealth malware behavior (period = 4 seconds for stealth)
        intensity = int(self.get("intensity") or 3)
        # Calculates period: Higher intensity reduces the period (max 6.0s, min 2.0s)
        period = max(2.0, 6.0 - intensity * 0.3)

        behav = self.StealthMalwareBehaviour(period=period)
        self.add_behaviour(behav)

        _log(f"Attack period: {period:.1f}s (intensity={intensity})")


async def main():
    """Parses command line arguments, initializes the MalwareAttacker agent, and runs the simulation."""
    parser = argparse.ArgumentParser(description="Malware Attacker - Sends malicious payloads")
    parser.add_argument("--jid", required=True, help="Attacker JID (e.g., attacker@localhost)")
    parser.add_argument("--password", help="Password (prompted if not provided)")
    parser.add_argument("--targets", required=True, help="Comma-separated target JIDs")
    parser.add_argument("--intensity", type=int, default=5, help="Attack intensity 1-10 (default: 5)")
    parser.add_argument("--duration", type=int, default=30, help="Attack duration in seconds (default: 30)")
    args = parser.parse_args()

    passwd = args.password or getpass.getpass(f"Password for {args.jid}: ")
    targets = [t.strip() for t in args.targets.split(',') if t.strip()]

    agent = MalwareAttacker(args.jid, passwd)
    agent.set("targets", targets)
    agent.set("intensity", args.intensity)
    agent.set("duration", args.duration)

    try:
        await agent.start(auto_register=True)
        _log(f"Agent started - targeting {len(targets)} nodes")
        await spade.wait_until_finished(agent)
    except KeyboardInterrupt:
        _log("Stopping attack...")
    finally:
        await agent.stop()


if __name__ == "__main__":
    spade.run(main())